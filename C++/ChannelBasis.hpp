/// \mainpage Channel Coding Toolbox
///
/// This toolbox gives an implementation of the channel coding methods (also called population codes, distribution fields, ...).
/// In particular, (weighted) channel representations of one or several measurements of arbitrary dimensionality can be computed.
/// If those measurements are feature fields in images, the so-called channel-coded feature maps (CCFMs) are generated.
///
/// The code is free to use for academic purposes, but resulting publications should cite our prior work, in particular
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-74735
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-79260
///
/// Please contact the authors if you intend commercial use:
///
/// Michael Felsberg, Link&ouml;ping University, Sweden
///
/// michael.felsberg@liu.se
///
/// (C) Fredrik Larsson 2009, Michael Felsberg 2010-2012
///
/// \section installation Installation
///
/// The toolbox comes along with Eclipse project files. Using Eclipse is the easiest way to compile. However, there is also
/// a makefile so that you can compile directly on the command line. The only dependency is OpenCV. Due to bugs in previous
/// versions, at least OpenCV 2.4 is needed. The toolbox comes with a test function ChannelBasisTest.cpp, that may be considered
/// as a practical example of use. If compiled in Debug profile, an executable using the test function is built. If compiled in
/// release profile, the shared library is built.
///
/// \section usecases How to use the classes
///
/// The toolbox basically generates extended OpenCV's matrices with coding functionality - both for dense and sparse matrices.
/// There are many different possible ways to use this toolbox. In all cases, one
/// first constructs the basis for the coding. Once the basis is defined one can generate one or several new
/// vector(s) by encoding data. After processing the vectors, the result may either be decoded or matched
/// with other vectors.
///
/// \subsection basis Generate basis
///
/// Bases can either be simple or combined. A simple basis is generated by choosing a type of basis function,
/// the number of channels, and the interval bounds. As optional parameters one might choose whether the
/// channels are modular (periodic) or, if non-modular, whether all channels should lie within the bounds
/// (this latter option is usually not required).
/// \code
/// Cos2ChannelBasis myBasis;
/// \endcode
/// generates a cosine-square basis. Similarly,
/// \code
/// BsplineChannelBasis myBasis;
/// \endcode
/// generates a quadratic B-spline basis. In both cases, the parameters are set (here: 10 channels, interval [0 255]) using
/// \code
/// myBasis.setParameters(10, 0, 255);
/// \endcode
/// or 8 modular channels for angles [0, 360)
/// \code
/// myBasis.setParameters(8, 0, 360, 1);
/// \endcode
/// For debugging purposes, it is sometimes useful to display the basis
/// \code
/// myBasis.displayParameters();
/// \endcode
/// Combined bases are generated by (virtual) outer products of existing bases (here: myBasis1, myBasis2)
/// \code
/// CombinedChannelBasis myCombinedBasis;
/// std::vector<ChannelBasis*> myBasisVector(2);
/// myBasisVector[0] = &myBasis1;
/// myBasisVector[1] = &myBasis2;
/// myCombinedBasis.setParameters(myBasisVector);
/// \endcode
/// Displaying combined channels also works, but the provided information is very limited. Instead one
/// might want to loop through the elements of the basis vector (might change in future release).
///
/// \subsection vectors Use of channel vectors
///
/// The simples case is to encode one single measured value (i.e., value is an OpenCV Mat 1x1, single channel)
/// \code
/// ChannelVector myChannelVector(&myBasis);
/// myChannelVector.addSample(value);
/// \endcode
/// The resulting channel vector is a row vector with the number of elements determined by the basis object
/// (10 / 8 in the examples above). The vector is decoded using
/// \code
/// cv::Mat_<float> resultMat;
/// myChannelVector.decode(resultMat);
/// \endcode
/// The matrix resultMat is 1x1 with two channels, it contains the decoded value and the corresponding certainty.
///
/// If several values are added successively using the addSample method, the vector might contain several
/// modes. Several modes can be extracted by passing another parameter
/// \code
/// myChannelVector.decode(resultMat,3);
/// \endcode
/// This example results in a 1x1 matrix with 3x2 = 6 channels.
///
/// If an [mxn] matrix of values is encoded, the resulting channel vector becomes a matrix with m*n rows.
/// The values of m and n are stored internally, i.e., if spatial processing is required, the matrix need
/// reshaping. This is achieved using the channelImage() member. A similar rearrangement is obtained using
/// histogramMatrix(), being compatible to standard histograms in OpenCV. Both functions do not copy the data,
/// i.e., the original channel vector can be used for decoding.
///
/// The channel vector can either be computed with or without explicit weight. Also, if several measurements
/// are given, their (implicit) index might be encoded as well, leading to a spatial low-pass filtering
/// and simultaneous subsampling. The resulting representation is referred to as channel-coded feature map (CCFM).
/// The resulting four cases are automatically determined by the difference of dimensions between the number
/// of channels in the input data and the number of channels in the channel vector.
/// - -2 means two extra channels in the channel vector. These are used to encode the spatial index (CCFM)
/// - -1 same as above, but a weight is given explicitly. The last channel in the input data is used to weight
/// the whole CCFM
/// - 0 no weights are given, no encoding of the spatial index
/// - 1 weights are given explicitly, no encoding of the spatial index
///
/// For instance, if hue and orientation should be encoded in a CCFM, a two channel matrix has to be generated
/// where the first channel contains the hue image and the second the orientation image. Then, four channel bases
/// have to be produced, one for each spatial coordinate, hue, and orientation. These are then combined and
/// the corresponding CombinedChannelBasis object is initiated. The resulting CCFM is a column vector of length
/// numberXchannels*numberYchannels*numberHuechannels*numberOrientationchannels.
///
/// If the same data should also be weighted while encoding, the data matrix needs to have a third channel with
/// the respective weights.
///
/// If instead the same data should result in an image of channel vectors where each vector represents the hue
/// and orientation, the combined channel basis should only contain the channel bases for hue and orientation.
///
/// Channel smoothing of the image fImage is thus done by the following code fragment
/// \code
/// myBasis.setParameters(10, 0, 255);
/// ChannelVector myChannelVector(&myBasis);
/// myChannelVector.addSample(fImage);
/// cv::Mat channelImage
/// cCVB.channelImage(channelImage);
/// cv::GaussianBlur(channelImage, channelImage, cv::Size(7,7), 1.5, 1.5);
/// cv::Mat fImage2;
/// myChannelVector.decode(fImage2);
/// std::vector<cv::Mat_<float> > fImageLayers(2);
/// cv::split(fImage2,fImageLayers);
/// cv::namedWindow("Channel Image");
/// cv::imshow("Channel Image", fImageLayers[0]);
/// \endcode

/// \file ChannelBasis.h
/// \brief The header file containing all classes of the channel toolbox and required helper functions.

#pragma once
#define _USE_MATH_DEFINES 

#include <opencv2/opencv.hpp>
#include <iostream>
#include <limits>

namespace cvl {

/// \brief Base class for simple and combined channel bases.
///
/// Defines common methods and data structures.
/// The implementations is based
/// on the following publications, which should be cited if this code is used:
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-74735
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-79260
///
/// (C) Fredrik Larsson 2009, Michael Felsberg 2010-2012
class ChannelBasis{

public:  

	/// \brief Standard constructor
	///
	ChannelBasis();

	/// \brief Destructor
	///
	virtual ~ChannelBasis() {};

	/// \brief Setting the class parameters
	/// \param nChannels number of channels
	/// \param minValue lower bound of encoded values
	/// \param maxValue upper bound of encoded values
	/// \param modularChannels channel vectors are peridoic (e.g. for orientation channels)
	/// \param boundedChannels obsolete
	void setParameters(const int nChannels, const float minValue, const float maxValue, const int modularChannels=0, const int boundedChannels=1);      

	/// \brief Displays the configuration of the class
	///
	void displayParameters() const; // TODO: make virtual(?)

	/// \brief Displays the type of basis function
	///
	virtual void displayBasisType() const {};

	/// \brief Calculates the total number of channels
	/// \return total number of channels
	const int getNrChannels() const;

	/// \brief Produces a vector which contains the individual number of channels for each basis (for CombinedChannelBasis).
	/// \param nrChansVec reference to an STL-vector that will contain the vector of number of channels
	virtual void getNrChannelsVec(std::vector<int> &nrChansVec) const {};

	/// \brief The upper bound of the decoded value
	/// \return upper bound
	const float getMaxV() const;

	/// \brief The lower bound of the decoded value
	/// \return lower bound
	const float getMinV() const;

	/// \brief The norm of the basis function
	/// \return norm
	const float getNorm() const;

	/// \brief Encoding functionality for a single value in a dense simple channel
	/// \param chCoefficients matrix that contains the coefficients
	/// \param val value to be encoded
	virtual void encode(cv::Mat_<float> &chCoefficients, const float val) const {};

	/// \brief Encoding functionality for a single value in a dense combined channel
	/// \param chCoefficients matrix that contains the coefficients
	/// \param vals value-vector to be encoded
	virtual void encode(cv::Mat_<float> &chCoefficients, const std::vector<float> &vals) const {encode(chCoefficients, vals[0]);};

	/// \brief Encoding functionality for a single value in a sparse simple channel
	/// \param chCoefficients matrix that contains the coefficients
	/// \param val value to be encoded
	virtual void encode(cv::SparseMat_<float> &chCoefficients, const float val) const {};

	/// \brief Encoding functionality for a single value in a sparse combined channel
	/// \param chCoefficients matrix that contains the coefficients
	/// \param vals value-vector to be encoded
	virtual void encode(cv::SparseMat_<float> &chCoefficients, const std::vector<float> &vals) const {encode(chCoefficients, vals[0]);};

	/// \brief Decoding functionality for all cases
	/// \param res multi-channel matrix that contains the decoded data. Each channel contains the respective feature dimension.
	/// For CCFMs, the third and second but last contain the spatial coordinates. The last one contains the confidence.
	/// For multiple modes (given as nrModes), the matrix elements contain nrModes times as many elements, at maximum CV_CN_MAX, though.
	/// For a field of channel vectors (e.g. one at each image position)
	/// the matrix corresponds to the field size.
	/// \param chCoeff channel coefficients as produced by the encoding.
	/// \param nrModes the number of modes to be decoded.
	virtual void decode(cv::Mat_<float> &res, const cv::Mat_<float> &chCoeff, const int nrModes=1) const {};

	/// \brief Decoding functionality for all cases
	/// \param res multi-channel matrix that contains the decoded data. Each channel contains the respective feature dimension.
	/// For CCFMs, the third and second but last contain the spatial coordinates. The last one contains the confidence.
	/// For multiple modes (given as nrModes), the matrix elements contain nrModes times as many elements, at maximum CV_CN_MAX, though.
	/// For a field of channel vectors (e.g. one at each image position)
	/// the matrix corresponds to the field size.
	/// \param sparse chCoeff channel coefficients as produced by the encoding.
	/// \param nrModes the number of modes to be decoded.
	virtual void decode(cv::Mat_<float> &res, const cv::SparseMat_<float> &chCoeff, const int nrModes=1) const {cv::Mat_<float> tmpcC; chCoeff.copyTo(tmpcC);decode(res,tmpcC,nrModes);};

	// member variables and internal functions
protected:
	int    m_modular;
	float  m_minV, m_maxV;
	float  m_scaling,m_offset;
	float  m_width;
	int    m_nChans;
	int    m_bounded;
	float  m_norm;
	void updateInputScaling();
	void scaleInput(float &val) const;
};

// helper function
void sortModes(std::vector<float> &resVec, std::vector<float> &confVec, std::vector<float> &res, std::vector<float> &certainty);

/// \brief Cos2 channels basis class
///
/// Inherits interfaces from ChannelBasis and implements the needed functionalities for cosine-square basis functions.
/// The implementations is based
/// on the following publications, which should be cited if this code is used:
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-74735
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-79260
///
/// (C) Fredrik Larsson 2009, Michael Felsberg 2010-2012
class Cos2ChannelBasis : public ChannelBasis{ 
public:

	/// \brief Standard constructor
	///
	Cos2ChannelBasis();

	/// \brief Cos2 channel encoding of a single value into dense vector
	/// \param chCoefficients matrix that contains the coefficients
	/// \param val value to be encoded
	void encode(cv::Mat_<float> &chCoefficients, const float val) const;

	/// \brief Cos2 channel encoding of a single value into sparse vector
	/// \param chCoefficients matrix that contains the coefficients
	/// \param val value to be encoded
	void encode(cv::SparseMat_<float> &chCoefficients, const float val) const;

	/// \brief Displays the type of basis function (cos2)
	///
	virtual void displayBasisType() const;

	/// \brief Decoding functionality for cos2 channels
	/// \param res multi-channel matrix that contains the decoded data. Each channel contains the respective feature dimension.
	/// For CCFMs, the third and second but last contain the spatial coordinates. The last one contains the confidence.
	/// For multiple modes (given as nrModes), the matrix elements contain nrModes times as many elements, at maximum CV_CN_MAX, though.
	/// For a field of channel vectors (e.g. one at each image position)
	/// the matrix corresponds to the field size.
	/// \param chCoeff channel coefficients as produced by the encoding.
	/// \param nrModes the number of modes to be decoded.
	void decode(cv::Mat_<float> &res, const cv::Mat_<float> &chCoeff, const int nrModes=1) const;

private:
};

/// \brief Bspline channels basis class
///
/// Inherits interfaces from ChannelBasis and implements the needed functionalities for quadratic B-spline basis functions.
/// The implementations is based
/// on the following publications, which should be cited if this code is used:
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-74735
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-79260
///
/// (C) Fredrik Larsson 2009, Michael Felsberg 2010-2012
class BsplineChannelBasis : public ChannelBasis{ 
public:

	/// \brief Standard constructor
	///
	BsplineChannelBasis();

	/// \brief Bspline channel encoding of a single value into dense vector
	/// \param chCoefficients matrix that contains the coefficients
	/// \param val value to be encoded
	void encode(cv::Mat_<float> &chCoefficients, const float val) const;

	/// \brief Bspline channel encoding of a single value into sparse vector
	/// \param chCoefficients matrix that contains the coefficients
	/// \param val value to be encoded
	void encode(cv::SparseMat_<float> &chCoefficients, const float val) const;

	/// \brief Displays the type of basis function (Bspline)
	///
	virtual void displayBasisType() const;

	/// \brief Decoding functionality for bspline channels
	/// \param res multi-channel matrix that contains the decoded data. Each channel contains the respective feature dimension.
	/// For CCFMs, the third and second but last contain the spatial coordinates. The last one contains the confidence.
	/// For multiple modes (given as nrModes), the matrix elements contain nrModes times as many elements, at maximum CV_CN_MAX, though.
	/// For a field of channel vectors (e.g. one at each image position)
	/// the matrix corresponds to the field size.
	/// \param chCoeff channel coefficients as produced by the encoding.
	/// \param nrModes the number of modes to be decoded.
	void decode(cv::Mat_<float> &res, const cv::Mat_<float> &chCoeff, const int nrModes=1) const;

private:
};

/// \brief Combined channels basis class
///
/// Inherits interfaces from ChannelBasis and implements the needed functionalities for outer products of other basis functions.
/// The implementations is based
/// on the following publications, which should be cited if this code is used:
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-74735
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-79260
///
/// (C) Fredrik Larsson 2009, Michael Felsberg 2010-2012
class CombinedChannelBasis : public ChannelBasis {
public:

	/// \brief Standard constructor
	///
	CombinedChannelBasis();

	/// \brief Setting the class parameters
	/// \param chBasisVector an STL vector of ChannelBasis objects
	void setParameters(const std::vector<ChannelBasis*> chBasisVector);

	/// \brief Produces a vector which contains the individual number of channels for each basis.
	/// \param nrChansVec reference to an STL-vector that will contain the vector of number of channels
	void getNrChannelsVec(std::vector<int> &nrChansVec) const;

	/// \brief Combined channel encoding of a feature vector into dense vector
	/// \param chCoefficients matrix that contains the coefficients
	/// \param vals feature vector to be encoded
	void encode(cv::Mat_<float> &chCoefficients, const std::vector<float> &vals) const;

	/// \brief Combined channel encoding of a feature vector into sparse vector
	/// \param chCoefficients matrix that contains the coefficients
	/// \param vals feature vector to be encoded
	void encode(cv::SparseMat_<float> &chCoefficients, const std::vector<float> &vals) const;

	/// \brief Displays the type of basis function (combined channels)
	///
	virtual void displayBasisType() const;

	/// \brief Decoding functionality for combined channels
	/// \param res multi-channel matrix that contains the decoded data. Each channel contains the respective feature dimension.
	/// For CCFMs, the third and second but last contain the spatial coordinates. The last one contains the confidence.
	/// For multiple modes (given as nrModes), the matrix elements contain nrModes times as many elements, at maximum CV_CN_MAX, though.
	/// For a field of channel vectors (e.g. one at each image position)
	/// the matrix corresponds to the field size.
	/// \param chCoeff channel coefficients as produced by the encoding.
	/// \param nrModes the number of modes to be decoded.
	void decode(cv::Mat_<float> &res, const cv::Mat_<float> &chCoeff, const int nrModes=1) const;

	/// \brief Decoding functionality for combined channels
	/// \param res multi-channel matrix that contains the decoded data. Each channel contains the respective feature dimension.
	/// For CCFMs, the third and second but last contain the spatial coordinates. The last one contains the confidence.
	/// For multiple modes (given as nrModes), the matrix elements contain nrModes times as many elements, at maximum CV_CN_MAX, though.
	/// For a field of channel vectors (e.g. one at each image position)
	/// the matrix corresponds to the field size.
	/// \param chCoeff sparse channel coefficients as produced by the encoding.
	/// \param nrModes the number of modes to be decoded.
	void decode(cv::Mat_<float> &res, const cv::SparseMat_<float> &chCoeff, const int nrModes=1) const;

	// some additional member variables
private:
	std::vector<ChannelBasis*> m_chBasisVector;
	std::vector<int> m_nChansVec;
};

/// \brief Channel vector class
///
/// Inherits from dense OpenCV Mat, extends with a ChannelBasis object, and implements the needed functionalities.
/// The implementations is based
/// on the following publications, which should be cited if this code is used:
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-74735
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-79260
///
/// (C) Fredrik Larsson 2009, Michael Felsberg 2010-2012
class ChannelVector : public cv::Mat_<float>{
public:
	/// \brief Standard constructor
	///
	ChannelVector();

	/// \brief Constructor with basis initialization
	///
	/// Constructs data structure including adding a channel basis
	/// \param chBasis pointer to a valid ChannelBasis object
	ChannelVector(ChannelBasis *chBasis);

	/// \brief Constructor with basis initialization and copying coefficient matrix
	///
	/// Constructs data structure including adding a channel basis and a coefficient matrix.
	/// Is useful if copying channel vector objects is inevitable.
	/// \param chBasis pointer to a valid ChannelBasis object
	/// \param coeffs a matrix with channel coefficients of appropriate dimensionality
	ChannelVector(ChannelBasis *chBasis, const cv::Mat_<float> coeffs);

	/// \brief Add sample(s) functionality
	///
	/// Cumulative distributions will be generated. There are several possible uses of this, depending on the input matrix.
	/// \param vals Float matrix with values to be encoded and added. There are many different potential uses of this,
	/// see main page.
	void addSample(const cv::Mat &vals);

	/// \brief Decoding functionality
	/// \param res Matrix that contains the decoded values after the call. For layout, see main page.
	/// \param nrModes Number of modes that are extracted from the ChannelVector.
	void decode(cv::Mat &res, const int nrModes=1) const;

	/// \brief Normalize the vector
	///
	void normalize();

	/// \brief Set or change the channel basis to be used
	/// \param chBasis A pointer to a ChannelBasis object
	void setChannelBasis(ChannelBasis *chBasis);

	/// \brief Generate different layout, suitable for channel smoothing
	/// \param res Matrix that contains the data in new layout. No copying is done, i.e., no inverse mapping is required!
	void channelImage(cv::Mat &res) const;

	/// \brief Generate different layout, compatible with histograms (N-D matrices); last dimension corresponds to the previous rows
	/// \param res Matrix that contains the data in new layout. No copying is done, i.e., no inverse mapping is required!
	void histogramMatrix(cv::Mat & res) const;

	// some few member variables that are required
private:  
	ChannelBasis  *m_chBasis;
	std::vector<int> m_support;
};

/// \brief Sparse channel vector class
///
/// Inherits from dense OpenCV Mat, extends with a ChannelBasis object, and implements the needed functionalities.
/// The implementations is based
/// on the following publications, which should be cited if this code is used:
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-74735
///
/// http://urn.kb.se/resolve?urn=urn:nbn:se:liu:diva-79260
///
/// (C) Fredrik Larsson 2009, Michael Felsberg 2010-2012
class ChannelSVector : public cv::SparseMat_<float>{
public:
	/// \brief Standard constructor
	///
	ChannelSVector();

	/// \brief Constructor with basis initialization
	///
	/// Constructs data structure including adding a channel basis
	/// \param chBasis pointer to a valid ChannelBasis object
	ChannelSVector(ChannelBasis *chBasis);

	/// \brief Add sample(s) functionality
	///
	/// Cumulative distributions will be generated. There are several possible uses of this, depending on the input matrix.
	/// \param vals Sparse float matrix with values to be encoded and added. There are many different potential uses of this,
	/// see main page.
	void addSample(const cv::Mat &vals);

	/// \brief Decoding functionality
	/// \param res Matrix that contains the decoded values after the call. For layout, see main page.
	/// \param nrModes Number of modes that are extracted from the ChannelSVector.
	void decode(cv::Mat_<float> &res, const int nrModes=1) const;

	/// \brief Normalize the vector
	///
	void normalize();

	/// \brief Set or change the channel basis to be used
	/// \param chBasis A pointer to a ChannelBasis object
	void setChannelBasis(ChannelBasis *chBasis);

	// some few member variables that are required
private:  
	ChannelBasis  *m_chBasis;
	std::vector<int> m_support;
};

}

/// \brief Stream operator for ChannelVector objects
/// \param os Output stream
/// \param v ChannelVector object to be printed
/// \return modfied stream
std::ostream &operator << (std::ostream &os, const cvl::ChannelVector &v);

/// \brief Stream operator for ChannelSVector objects
/// \param os Output stream
/// \param v ChannelSVector object to be printed
/// \return modfied stream
std::ostream &operator << (std::ostream &os, const cvl::ChannelSVector &v);
